package ar.edu.itba.kUltra;

import java_cup.runtime.*;
import org.objectweb.asm.commons.GeneratorAdapter;
import ar.edu.itba.kUltra.nodes.*;
import ar.edu.itba.kUltra.symbols.*;

parser code {:
    Scanner scanner;

  public Parser(Scanner scann, ComplexSymbolFactory sf) {
    super(scann,sf);
    scanner = scann;
  }

	public static void main(String args[]) throws Exception {
		ComplexSymbolFactory sf = new ComplexSymbolFactory();
		if (args.length==0) new Parser(new Scanner(System.in,sf),sf).parse();
		else new Parser(new Scanner(new java.io.FileInputStream(args[0]),sf),sf).parse();
	}
:}

terminal MINUS, PLUS, MULT, DIV, MOD;
terminal AND, OR;
terminal LT, LTEQ, GT, GTEQ, EQEQ, NOTEQ, EQ;
terminal LPAREN, RPAREN;
terminal SEMICOLON, COMMA, COLON;
terminal INT, STR, VOID;
terminal RETURN, DEF, END, IF, ELSE, WHILE;


terminal Integer INTEGER;
terminal String STRING, IDENTIFIER;


non terminal ProgramNode Program;
non terminal NodeList<MethodNode> MethodList;
non terminal MethodNode Method;
non terminal ReturnNode Return;
non terminal ParameterListSymbol Parameters;
non terminal String Type;
non terminal BodyNode StatementList;
non terminal StatementNode Statement;
non terminal ExpressionNode Expression;
non terminal VariableNode Variable;
non terminal DeclarationNode VarDeclaration;
non terminal AssignmentNode Assignment;
non terminal IfNode If;
non terminal WhileNode While;
non terminal MethodCallNode MethodCall;
non terminal NodeList<ExpressionNode> Arguments;
non terminal LiteralNode Literal;

precedence left AND, OR;
precedence left MINUS, PLUS, MULT, DIV, MOD;
precedence left LT, LTEQ, GT, GTEQ;
precedence left EQEQ, NOTEQ;

start with Program;


Program                 ::=             MethodList:ml StatementList:sl {: RESULT = new ProgramNode(ml, sl); :}
                                        ;


MethodList              ::=             Method:m MethodList:ml {: ml.add(m); RESULT = ml; :}
                                        | /* lambda */ {: RESULT = new NodeList<>(); :}
                                        ;

Method                  ::=             DEF Type:t IDENTIFIER:i LPAREN Parameters:p RPAREN COLON StatementList:sl END
                     {: RESULT = new MethodNode(t, i, p, sl); :}
                                        ;

Return                  ::=             RETURN Expression:e SEMICOLON {: RESULT = new ReturnNode(e); :}
                                        ;

Parameters              ::=             Type:t IDENTIFIER:i COMMA Parameters:p {: p.addParameter(t, i); RESULT = p; :}
                                        | Type:t IDENTIFIER:i {: RESULT = new ParameterListSymbol(); RESULT.addParameter(t, i); :}
                                        | /* lambda */ {: RESULT = new ParameterListSymbol(); :}
                                        ;

Type                    ::=             INT {: RESULT ="Integer"; :}
                                        | STR {: RESULT ="String"; :}
                                        | VOID {: RESULT ="void"; :}
                                        ;

StatementList           ::=             Statement:s StatementList:sl  {: sl.add(s); RESULT = sl; :}
                                        | /* lambda */ {: RESULT = new BodyNode(); :}
                                        ;

Statement               ::=             VarDeclaration:vd {: RESULT = vd; :}
                                        | Assignment:a {: RESULT = a; :}
                                        | If:i {: RESULT = i; :}
                                        | While:w {: RESULT = w; :}
                                        | MethodCall:mc {: RESULT = mc; :}
                                        ;

Expression              ::=             Expression:e1 MINUS Expression:e2 {: RESULT = new ArithmeticNode(GeneratorAdapter.SUB, e1, e2); :}
                                        | Expression:e1 PLUS Expression:e2 {: RESULT = new ArithmeticNode(GeneratorAdapter.ADD, e1, e2); :}
                                        | Expression:e1 MULT Expression:e2 {: RESULT = new ArithmeticNode(GeneratorAdapter.MUL, e1, e2); :}
                                        | Expression:e1 DIV Expression:e2 {: RESULT = new ArithmeticNode(GeneratorAdapter.DIV, e1, e2); :}
                                        | Expression:e1 MOD Expression:e2 {: RESULT = new ArithmeticNode(GeneratorAdapter.REM, e1, e2); :}
                                        | Expression:e1 AND Expression:e2 {: RESULT = new RelationalNode(GeneratorAdapter.AND, e1, e2); :}
                                        | Expression:e1 OR Expression:e2 {: RESULT = new RelationalNode(GeneratorAdapter.OR, e1, e2); :}
                                        | Expression:e1 LT Expression:e2 {: RESULT = new RelationalNode(GeneratorAdapter.LT, e1, e2); :}
                                        | Expression:e1 LTEQ Expression:e2 {: RESULT = new RelationalNode(GeneratorAdapter.LE, e1, e2); :}
                                        | Expression:e1 GT Expression:e2 {: RESULT = new RelationalNode(GeneratorAdapter.GT, e1, e2); :}
                                        | Expression:e1 GTEQ Expression:e2 {: RESULT = new RelationalNode(GeneratorAdapter.GE, e1, e2); :}
                                        | Expression:e1 EQEQ Expression:e2 {: RESULT = new RelationalNode(GeneratorAdapter.EQ, e1, e2); :}
                                        | Expression:e1 NOTEQ Expression:e2 {: RESULT = new RelationalNode(GeneratorAdapter.NE, e1, e2); :}
                                        | MINUS Expression:e {: RESULT = new ArithmeticNode(GeneratorAdapter.SUB, new LiteralNode<>(0), e); :} // +++ximprove
                                        | LPAREN Expression:e RPAREN {: RESULT = e; :}
                                        | MethodCall:mc {: RESULT = mc; :}
                                        | Literal:l {: RESULT = l; :}
                                        | Variable:v {: RESULT = v; :}
                                        ;


Variable                ::=             IDENTIFIER:i {: RESULT = new VariableNode(i); :}
                                        ;

VarDeclaration          ::=             Type:t IDENTIFIER:i SEMICOLON {: RESULT = new DeclarationNode(t, i); :}
                                        ;

Assignment              ::=             IDENTIFIER:i EQ Expression:e SEMICOLON {: RESULT = new AssignmentNode(i, e); :}
                                        ;

If                      ::=             IF LPAREN Expression:c RPAREN COLON StatementList:sl END {: RESULT = new IfNode(c, sl, null); :}
                                        |
                                        IF LPAREN Expression:c RPAREN COLON StatementList:sl ELSE COLON StatementList:el END {: RESULT = new IfNode(c, sl, el); :}
                                        ;

While                   ::=             WHILE LPAREN Expression:c RPAREN COLON StatementList:sl END {: RESULT = new WhileNode(c, sl); :}
                                        ;

MethodCall              ::=             IDENTIFIER:i LPAREN Arguments:a RPAREN SEMICOLON {: RESULT = new MethodCallNode(i, a); :}
                                        ;

Arguments               ::=             Expression:e COMMA Arguments:a {: a.add(e); RESULT = a;  :}
                                        | Expression:e {: RESULT = new NodeList<>(); RESULT.add(e); :}
                                        | /* lambda */ {: RESULT = new NodeList<>(); :}
                                        ;

Literal                 ::=             INTEGER:n {: RESULT = new LiteralNode<>(n); :}
                                        |
                                        STRING:s {: RESULT = new LiteralNode<>(s); :};
                                        

