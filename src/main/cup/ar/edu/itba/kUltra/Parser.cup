package ar.edu.itba.kUltra;

import java_cup.runtime.*;
import org.objectweb.asm.commons.GeneratorAdapter;
import ar.edu.itba.kUltra.nodes.*;
import ar.edu.itba.kUltra.symbols.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


parser code {:
    private final static Logger LOGGER = LoggerFactory.getLogger(Parser.class);
    Scanner scanner;

  public Parser(Scanner scann, ComplexSymbolFactory sf) {
    super(scann,sf);
    scanner = scann;
  }

	public static void main(String args[]) throws Exception {
		ComplexSymbolFactory sf = new ComplexSymbolFactory();
		if (args.length==0) new Parser(new Scanner(System.in,sf),sf).parse();
		else new Parser(new Scanner(new java.io.FileInputStream(args[0]),sf),sf).parse();
	}
:}

terminal MINUS, PLUS, MULT, DIV, MOD, UMINUS; // UMINUS is a terminal JUST defined for precedence purposes
terminal AND, OR;
terminal LT, LTEQ, GT, GTEQ, EQEQ, NOTEQ, EQ;
terminal LPAREN, RPAREN;
terminal SEMICOLON, COMMA, COLON;
terminal INT, STR, VOID; // +++xcheck
terminal RETURN, DEF, END, IF, ELSE, WHILE;


terminal Integer INTEGER;
terminal String STRING, IDENTIFIER;
// terminal void VOID; +++xcheck


non terminal ProgramNode Program;
non terminal NodeList<MethodNode> MethodList;
non terminal MethodNode Method;
non terminal ReturnNode Return;
non terminal ParameterListSymbol Parameters;
non terminal String Type;
non terminal BodyNode StatementList;
non terminal StatementNode Statement;
non terminal ExpressionNode Expression;
non terminal VariableNode Variable;
non terminal DeclarationNode VarDeclaration;
non terminal AssignmentNode Assignment;
non terminal IfNode If;
non terminal WhileNode While;
non terminal MethodCallNode MethodCall;
non terminal NodeList<ExpressionNode> Arguments;
non terminal LiteralNode Literal;


precedence left Variable, MethodCall;
precedence left RETURN;

precedence left AND, OR;
precedence left LT, LTEQ, GT, GTEQ, EQEQ, NOTEQ;
precedence left MINUS, PLUS;
precedence left MULT, DIV, MOD;
precedence left UMINUS;

start with Program;


Program                 ::=             MethodList:ml StatementList:sl {: LOGGER.debug("Program"); RESULT = new ProgramNode(ml, sl); :}
                                        ;


MethodList              ::=             Method:m MethodList:ml {: LOGGER.debug("MethodList"); ml.add(m); RESULT = ml; :}
                                        | /* lambda */ {: LOGGER.debug("Lambda MethodList"); RESULT = new NodeList<>(); :}
                                        ;

Method                  ::=             DEF Type:t IDENTIFIER:i LPAREN Parameters:p RPAREN COLON StatementList:sl END
                     {: LOGGER.debug("Method"); RESULT = new MethodNode(t, i, p, sl); :}
                                        ;

Return                  ::=             RETURN Expression:e SEMICOLON {: LOGGER.debug("Return"); RESULT = new ReturnNode(e); :}
                                        ;

Parameters              ::=             Type:t IDENTIFIER:i COMMA Parameters:p {: LOGGER.debug("Parameters"); p.addParameter(t, i); RESULT = p; :}
                                        | Type:t IDENTIFIER:i {: LOGGER.debug("Parameters"); RESULT = new ParameterListSymbol(); RESULT.addParameter(t, i); :}
                                        | /* lambda */ {: LOGGER.debug("Parameters"); RESULT = new ParameterListSymbol(); :}
                                        ;

Type                    ::=             INT {: LOGGER.debug("Type"); RESULT ="Integer"; :}
                                        | STR {: LOGGER.debug("Type"); RESULT ="String"; :}
                                        | VOID {: LOGGER.debug("Type"); RESULT ="void"; :}
                                        ;

StatementList           ::=             Statement:s StatementList:sl  {: LOGGER.debug("StatementList"); sl.add(s); RESULT = sl; :}
                                        | /* lambda */ {: LOGGER.debug("StatementList"); RESULT = new BodyNode(); :}
                                        ;

Statement               ::=             VarDeclaration:vd {: LOGGER.debug("Statement"); RESULT = vd; :}
                                        | Assignment:a {: LOGGER.debug("Statement"); RESULT = a; :}
                                        | If:i {: LOGGER.debug("Statement"); RESULT = i; :}
                                        | While:w {: LOGGER.debug("Statement"); RESULT = w; :}
                                        | MethodCall:mc {: LOGGER.debug("Statement"); RESULT = mc; :}
                                        | Return:r {: LOGGER.debug("Statement"); RESULT = r; :}
                                        ;

Expression              ::=             Expression:e1 MINUS Expression:e2 {: LOGGER.debug("Expression"); RESULT = new ArithmeticNode(GeneratorAdapter.SUB, e1, e2); :}
                                        | Expression:e1 PLUS Expression:e2 {: LOGGER.debug("Expression"); RESULT = new ArithmeticNode(GeneratorAdapter.ADD, e1, e2); :}
                                        | Expression:e1 MULT Expression:e2 {: LOGGER.debug("Expression"); RESULT = new ArithmeticNode(GeneratorAdapter.MUL, e1, e2); :}
                                        | Expression:e1 DIV Expression:e2 {: LOGGER.debug("Expression"); RESULT = new ArithmeticNode(GeneratorAdapter.DIV, e1, e2); :}
                                        | Expression:e1 MOD Expression:e2 {: LOGGER.debug("Expression"); RESULT = new ArithmeticNode(GeneratorAdapter.REM, e1, e2); :}
                                        | Expression:e1 AND Expression:e2 {: LOGGER.debug("Expression"); RESULT = new RelationalNode(GeneratorAdapter.AND, e1, e2); :}
                                        | Expression:e1 OR Expression:e2 {: LOGGER.debug("Expression"); RESULT = new RelationalNode(GeneratorAdapter.OR, e1, e2); :}
                                        | Expression:e1 LT Expression:e2 {: LOGGER.debug("Expression"); RESULT = new RelationalNode(GeneratorAdapter.LT, e1, e2); :}
                                        | Expression:e1 LTEQ Expression:e2 {: LOGGER.debug("Expression"); RESULT = new RelationalNode(GeneratorAdapter.LE, e1, e2); :}
                                        | Expression:e1 GT Expression:e2 {: LOGGER.debug("Expression"); RESULT = new RelationalNode(GeneratorAdapter.GT, e1, e2); :}
                                        | Expression:e1 GTEQ Expression:e2 {: LOGGER.debug("Expression"); RESULT = new RelationalNode(GeneratorAdapter.GE, e1, e2); :}
                                        | Expression:e1 EQEQ Expression:e2 {: LOGGER.debug("Expression"); RESULT = new RelationalNode(GeneratorAdapter.EQ, e1, e2); :}
                                        | Expression:e1 NOTEQ Expression:e2 {: LOGGER.debug("Expression"); RESULT = new RelationalNode(GeneratorAdapter.NE, e1, e2); :}
                                        | MINUS Expression:e {: LOGGER.debug("Expression"); RESULT = new ArithmeticNode(GeneratorAdapter.SUB, new LiteralNode<>(0), e); :} /* +++ximprove */ %prec UMINUS
                                        | LPAREN Expression:e RPAREN {: LOGGER.debug("Expression"); RESULT = e; :}
                                        | MethodCall:mc {: LOGGER.debug("Expression"); RESULT = mc; :}
                                        | Literal:l {: LOGGER.debug("Expression"); RESULT = l; :}
                                        | Variable:v {: LOGGER.debug("Expression"); RESULT = v; :}
                                        ;


Variable                ::=             IDENTIFIER:i {: LOGGER.debug("Variable"); RESULT = new VariableNode(i); :}
                                        ;

VarDeclaration          ::=             Type:t IDENTIFIER:i SEMICOLON {: LOGGER.debug("VarDeclaration"); RESULT = new DeclarationNode(t, i); :}
                                        ;

Assignment              ::=             IDENTIFIER:i EQ Expression:e SEMICOLON {: LOGGER.debug("Assignment"); RESULT = new AssignmentNode(i, e); :}
                                        ;

If                      ::=             IF LPAREN Expression:c RPAREN COLON StatementList:sl END {: LOGGER.debug("If"); RESULT = new IfNode(c, sl, null); :}
                                        |
                                        IF LPAREN Expression:c RPAREN COLON StatementList:sl ELSE COLON StatementList:el END {: LOGGER.debug("If"); RESULT = new IfNode(c, sl, el); :}
                                        ;

While                   ::=             WHILE LPAREN Expression:c RPAREN COLON StatementList:sl END {: LOGGER.debug("While"); RESULT = new WhileNode(c, sl); :}
                                        ;

MethodCall              ::=             IDENTIFIER:i LPAREN Arguments:a RPAREN SEMICOLON {: LOGGER.debug("MethodCall"); RESULT = new MethodCallNode(i, a); :}
                                        ;

Arguments               ::=             Expression:e COMMA Arguments:a {: LOGGER.debug("Arguments"); a.add(e); RESULT = a;  :}
                                        | Expression:e {: LOGGER.debug("Arguments"); RESULT = new NodeList<>(); RESULT.add(e); :}
                                        | /* lambda */ {: LOGGER.debug("Arguments"); RESULT = new NodeList<>(); :}
                                        ;

Literal                 ::=             INTEGER:n {: LOGGER.debug("Literal"); RESULT = new LiteralNode<Integer>(n); :}
                                        |
                                        STRING:s {: LOGGER.debug("Literal"); RESULT = new LiteralNode<String>(s); :};
                                        

